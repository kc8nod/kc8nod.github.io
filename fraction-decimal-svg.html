<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nested Fraction Donut Chart - SVG</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: #f5f5f5;
    font-family: Arial, sans-serif;
  }
  body {
    overflow: hidden;
  }
  .chart-wrap {
    width: 100vw;
    height: 100vh;
    background: white;
  }
  svg {
    display: block;
    width: 100%;
    height: 100%;
    touch-action: none;
  }
  
  
  /* Label styles */
  .fraction-label circle{
    fill: url(#labelGrad);
  }

  .fraction-label text {
    font-size: medium;
    text-anchor: middle;
    dominant-baseline: middle;
    fill: #000;
  }
  
  .decimal-label text,
  .mm-label text {
    font-size: small;
    text-anchor: middle;
    dominant-baseline: middle;
    fill: #000;
  }
</style>
</head>
<body>

<div class="chart-wrap">
  <svg id="chart" width="1024" height="1024" viewBox="0 0 1024 1024">
    <defs>
      <radialGradient id="labelGrad" >
        <stop offset="0%" stop-color="rgba(255,255,255,0.95)" />
        <stop offset="60%" stop-color="rgba(255,255,255,0.60)" />
        <stop offset="100%" stop-color="rgba(255,255,255,0.0)" />
      </radialGradient>
    </defs>
  </svg>
</div>

<script src="https://unpkg.com/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
<script>
const svg = document.getElementById("chart");
const chartWrap = document.querySelector(".chart-wrap");

// Calculate dimensions from enclosing element
let width = document.body.clientWidth;
let height = Math.min(document.body.clientHeight, document.body.clientWidth * 1.2);

// Set SVG viewBox and dimensions to fill the window
svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
svg.setAttribute("width", width);
svg.setAttribute("height", height);

let cx = width / 8;
let cy = height / 2;

// Configurable rotation offset for the rings (radians). Change this to rotate the chart.
const startOffset = 0;

// Rings from 1/2 → 1/64
const fractionRings = [
  2,  // 1/2
  4,  // 1/4
  8,  // 1/8
  16, // 1/16
  32, // 1/32
  64  // 1/64
];

// SVG parameters
let outermostRadius = (width-cx) * .95;
let holeRadius = width * 0.05;

// GCD function
function gcd(a, b) {
  while (b !== 0) {
    [a, b] = [b, a % b];
  }
  return a;
}

// Helper to create SVG elements
function createSVGElement(tagName) {
  return document.createElementNS('http://www.w3.org/2000/svg', tagName);
}

// Generate a color palette for a ring
function getRingColors(slices, ringIndex, hue) {
  const saturation = 70;
  const lightnesses = [35, 55, 45, 65];
  
  const colors = [];
  for (let i = 0; i < slices; i++) {
    const lightness = lightnesses[i % 4];
    colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
  }
  return colors;
}

// Concatenate two arrays with priority
function concatSortedUniquePriority(primary, secondary, tol = 0.002) {
  const uniqPrimary = Array.from(new Set(primary));
  uniqPrimary.sort((a, b) => a - b);
  const result = uniqPrimary.slice();

  for (const s of secondary) {
    let clash = false;
    for (const r of result) {
      if (Math.abs(r - s) < tol) {
        clash = true;
        break;
      }
    }
    if (!clash) result.push(s);
  }

  result.sort((a, b) => a - b);
  return result;
}

// Create SVG arc path
function createArcPath(cx, cy, startAngle, endAngle, innerRadius, outerRadius) {
  const x1 = cx + outerRadius * Math.cos(startAngle);
  const y1 = cy + outerRadius * Math.sin(startAngle);
  const x2 = cx + outerRadius * Math.cos(endAngle);
  const y2 = cy + outerRadius * Math.sin(endAngle);
  
  const x3 = cx + innerRadius * Math.cos(endAngle);
  const y3 = cy + innerRadius * Math.sin(endAngle);
  const x4 = cx + innerRadius * Math.cos(startAngle);
  const y4 = cy + innerRadius * Math.sin(startAngle);
  
  const angleDiff = endAngle - startAngle;
  const largeArc = Math.abs(angleDiff) > Math.PI ? 1 : 0;
  const sweep1 = angleDiff > 0 ? 1 : 0;
  const sweep2 = angleDiff > 0 ? 0 : 1;
  
  return [
    `M ${x1} ${y1}`,
    `A ${outerRadius} ${outerRadius} 0 ${largeArc} ${sweep1} ${x2} ${y2}`,
    `L ${x3} ${y3}`,
    `A ${innerRadius} ${innerRadius} 0 ${largeArc} ${sweep2} ${x4} ${y4}`,
    'Z'
  ].join(' ');
}

// Draw slices for a ring
function drawSlices(ringIndex, endAngles, hue) {
  const slices = endAngles.length;
  const innerRadius = ringIndex * ringSpacing + holeRadius;
  const outerRadius = innerRadius + ringSpacing;
  const colors = getRingColors(slices, ringIndex, hue);
  
  const group = createSVGElement('g');
  group.setAttribute('class', `ring-slices-${ringIndex}`);
  
  for (let i = 1; i <= slices; i++) {
    const startAngle = (i === 1) ? startOffset : endAngles[i - 2];
    const endAngle = endAngles[i - 1];
    
    const path = createSVGElement('path');
    path.setAttribute('d', createArcPath(cx, cy, startAngle, endAngle, innerRadius, outerRadius));
    path.setAttribute('fill', colors[i - 1]);
    path.setAttribute('stroke', 'white');
    path.setAttribute('stroke-width', '1');
    
    group.appendChild(path);
  }
  
  chartGroup.appendChild(group);
}

function createLabel(type, value) {
  const group = createSVGElement('g');
  const contentGroup = createSVGElement('g');
  contentGroup.classList.add('label-content');

  if (type === 'fraction') {
    group.classList.add('fraction-label');
    
    const circle = createSVGElement('circle');
    circle.setAttribute('cx', '0');
    circle.setAttribute('cy', '0');
    circle.setAttribute('r', '1.2em');
    circle.setAttribute('fill', 'url(#labelGrad)');
    contentGroup.appendChild(circle);

    const numText = createSVGElement('text');
    numText.setAttribute('dy', '-0.5em');
    numText.textContent = value.numerator;
    contentGroup.appendChild(numText);

    const bar = createSVGElement('text');
    bar.textContent = '―';
    contentGroup.appendChild(bar);

    const denText = createSVGElement('text');
    denText.setAttribute('dy', '0.5em');
    denText.textContent = value.denominator;
    contentGroup.appendChild(denText);
  } else {
    const text = createSVGElement('text');
    text.textContent = type === 'decimal' ? value.toFixed(3) : value.toFixed(1) + ' ㎜';
    group.classList.add(type === 'decimal' ? 'decimal-label' : 'mm-label');
    contentGroup.appendChild(text);
  }

  group.appendChild(contentGroup);
  return group;
}

// Draw labels for a ring
function drawLabels(ringIndex, sliceLabels, endAngles, drawLeaders = true, radialAngle = false) {
  const slices = sliceLabels.length;
  const innerRadius = ringIndex * ringSpacing + holeRadius;
  const outerRadius = innerRadius + ringSpacing;
  
  const group = createSVGElement('g');
  group.setAttribute('class', `ring-labels-${ringIndex}`);
  
  for (let i = 1; i <= slices; i++) {
    const endAngle = endAngles[i - 1];
    const labelText = sliceLabels && sliceLabels[i - 1];
    
    if (labelText) {
      const labelAngle = endAngle;
      const labelRadius = (innerRadius + outerRadius) / 2;
      const labelX = cx + labelRadius * Math.cos(labelAngle);
      const labelY = cy + labelRadius * Math.sin(labelAngle);
      
      // Draw leader line if enabled
      if (drawLeaders) {
        const lineStartRadius = outerRadius - ringSpacing / 5;
        const x1 = cx + lineStartRadius * Math.cos(labelAngle);
        const y1 = cy + lineStartRadius * Math.sin(labelAngle);
        const x2 = cx + lineEndRadius * Math.cos(labelAngle);
        const y2 = cy + lineEndRadius * Math.sin(labelAngle);
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', 'rgba(0, 0, 0, 0.6)');
        line.setAttribute('stroke-width', '2');
        
        group.appendChild(line);
      }
      
      // Draw label - it's an SVG element
      const clonedLabel = labelText.cloneNode(true);
      clonedLabel.setAttribute('transform', `translate(${labelX}, ${labelY})`);
      clonedLabel.dataset.tx = `${labelX}`;
      clonedLabel.dataset.ty = `${labelY}`;
      
      if (radialAngle) {
        const angleDeg = (labelAngle * 180) / Math.PI;
        const flipDeg = Math.cos(labelAngle) < 0 ? 180 : 0;
        const existingTransform = clonedLabel.getAttribute('transform');
        clonedLabel.setAttribute('transform', `${existingTransform} rotate(${angleDeg + flipDeg})`);
        clonedLabel.dataset.baseAngle = `${labelAngle}`;
        clonedLabel.dataset.radial = '1';
      }
      
      group.appendChild(clonedLabel);
    }
  }
  
  chartGroup.appendChild(group);
}

// Pre-compute common decimal/mm values
const decimalValues = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
const n = Math.max(...fractionRings);
const decimalFractions = new Array(n).fill(0).map((_, idx) => (idx + 1) / n);
const mmValues = new Array(25).fill(0).map((_, idx) => (idx + 1)).concat([25.4]);
const decimalMillimeters = mmValues.map(val => val / 25.4);

// Build rings array
const rings = [];

// Fraction rings
for (let ringIndex = 0; ringIndex < fractionRings.length; ringIndex++) {
  const slices = fractionRings[ringIndex];
  const sliceLabels = new Array(slices).fill(null);
  
  for (let i = 1; i <= slices; i++) {
    if (gcd(i, slices) === 1) {
      sliceLabels[i - 1] = createLabel('fraction', { numerator: i, denominator: slices });
    }
  }
  
  const sliceAngle = (2 * Math.PI) / slices;
  const endAngles = new Array(slices).fill(0).map((_, idx) => startOffset - (idx + 1) * sliceAngle);
  
  rings.push({ ringIndex, endAngles, sliceLabels, labelAngles: endAngles, drawLeaders: true, radialAngle: false, hue: 120 });
}

// Decimal ring
{
  const allDecimals = concatSortedUniquePriority(concatSortedUniquePriority(decimalFractions, decimalMillimeters, 0.002), decimalValues, 0.004);
  const endAngles = new Array(10).fill(0).map((_, idx) => startOffset - (idx + 1) * (2 * Math.PI) / 10);
  const labelAngles = allDecimals.map(val => startOffset - val * 2 * Math.PI);
  const sliceLabels = allDecimals.map(val => createLabel('decimal', val));
  
  rings.push({ ringIndex: fractionRings.length, endAngles, sliceLabels, labelAngles, drawLeaders: false, radialAngle: true, hue: 220 });
}

// MM ring
{
  const mmFractions = decimalFractions.map(val => val * 25.4);
  const allMMValues = concatSortedUniquePriority(concatSortedUniquePriority(mmValues, mmFractions, 0.05), decimalValues.map(val => val * 25.4), 0.004 * 25.4);
  const endAngles = mmValues.map(v => startOffset - (v / 25.4) * 2 * Math.PI);
  const labelAngles = allMMValues.map(val => startOffset - (val / 25.4) * 2 * Math.PI);
  const sliceLabels = allMMValues.map(val => createLabel('mm', val));
  
  rings.push({ ringIndex: fractionRings.length + 1, endAngles, sliceLabels, labelAngles, drawLeaders: false, radialAngle: true, hue: 60 });
}

// Calculate ring spacing
const totalRings = rings.length;
let ringSpacing = (outermostRadius - holeRadius) / totalRings;
let lineEndRadius = outermostRadius - (2 * ringSpacing) + 2;

// Track zoom level for linear cx movement
let zoomLevel = 1;
const initialCx = cx;

// Initialize svg-pan-zoom first (it creates its own viewport)
let anchorSvgPoint = { x: cx + outermostRadius, y: cy };
let anchorScreenPoint = null;
let rotationDeg = 0;

const panZoom = svgPanZoom('#chart', {
  zoomEnabled: false,
  panEnabled: false,
  controlIconsEnabled: false,
  fit: false,
  center: false,
  mouseWheelZoomEnabled: false,
  dblClickZoomEnabled: false,
  touchEventsEnabled: false,
  preventMouseEventsDefault: true,
  minZoom: 1.0,
  maxZoom: 15
});

// Now create chartGroup inside svg-pan-zoom's viewport
const viewport = svg.querySelector('.svg-pan-zoom_viewport');
const chartGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
chartGroup.setAttribute('id', 'chartGroup');
viewport.appendChild(chartGroup);

// Draw all rings
rings.forEach(ring => {
  drawSlices(ring.ringIndex, ring.endAngles, ring.hue);
});
rings.forEach(ring => {
  drawLabels(ring.ringIndex, ring.sliceLabels, ring.labelAngles, ring.drawLeaders, ring.radialAngle);
});

function redrawChart() {
  chartGroup.innerHTML = '';
  rings.forEach(ring => {
    drawSlices(ring.ringIndex, ring.endAngles, ring.hue);
  });
  rings.forEach(ring => {
    drawLabels(ring.ringIndex, ring.sliceLabels, ring.labelAngles, ring.drawLeaders, ring.radialAngle);
  });
  chartGroup.setAttribute('transform', `rotate(${rotationDeg} ${cx} ${cy})`);
}

function updateAnchorForRotation() {
  const theta = (rotationDeg * Math.PI) / 180;
  anchorSvgPoint = {
    x: cx + outermostRadius * Math.cos(theta),
    y: cy + outermostRadius * Math.sin(theta)
  };
  const zoom = panZoom.getZoom();
  const pan = panZoom.getPan();
  anchorScreenPoint = {
    x: anchorSvgPoint.x * zoom + pan.x,
    y: anchorSvgPoint.y * zoom + pan.y
  };
}

function resetZoom() {
  panZoom.resetZoom();
  panZoom.fit();
  panZoom.center();
  updateAnchorForRotation();
}

// Fit/center and capture anchor point
panZoom.fit();
panZoom.center();
updateAnchorForRotation();

function rotateBy(deltaDeg) {
  rotationDeg = (rotationDeg + deltaDeg) % 360;
  chartGroup.setAttribute('transform', `rotate(${rotationDeg} ${cx} ${cy})`);
  
  chartGroup.querySelectorAll('.fraction-label .label-content').forEach((label) => {
    label.setAttribute('transform', `rotate(${-rotationDeg})`);
  });

  chartGroup.querySelectorAll('[data-radial="1"]').forEach((label) => {
    const baseAngle = parseFloat(label.dataset.baseAngle || '0');
    const angle = baseAngle + (rotationDeg * Math.PI) / 180;
    const flipDeg = Math.cos(angle) < 0 ? 180 : 0;
    const baseAngleDeg = (baseAngle * 180) / Math.PI;
    const tx = label.dataset.tx || '0';
    const ty = label.dataset.ty || '0';
    label.setAttribute('transform', `translate(${tx}, ${ty}) rotate(${baseAngleDeg + flipDeg})`);
  });

  // Don't update anchorScreenPoint - it stays fixed on screen
  // Only update the SVG point that corresponds to that screen position
  const zoom = panZoom.getZoom();
  const pan = panZoom.getPan();
  
  // Calculate which SVG point is currently at the anchor screen position
  anchorSvgPoint = {
    x: (anchorScreenPoint.x - pan.x) / zoom,
    y: (anchorScreenPoint.y - pan.y) / zoom
  };
}

function normalizeAngleDelta(deltaRad) {
  if (deltaRad > Math.PI) return deltaRad - 2 * Math.PI;
  if (deltaRad < -Math.PI) return deltaRad + 2 * Math.PI;
  return deltaRad;
}

function angleFromCenter(point, center) {
  return Math.atan2(point.y - center.y, point.x - center.x);
}

svg.addEventListener('wheel', (event) => {
  event.preventDefault();
  if (event.ctrlKey) {
    const cxDelta = event.deltaY * 1.0;
    cx = Math.min(cx + cxDelta, width / 2);
    //holeRadius = Math.max(holeRadius - cxDelta, 10);
    if( cx < 0) {holeRadius = holeRadius - cxDelta;}
    outermostRadius = (width - cx) * 0.95;
    ringSpacing = (outermostRadius - holeRadius) / totalRings;
    lineEndRadius = outermostRadius - (2 * ringSpacing) + 2;
    redrawChart();
  } else {
    const deltaDeg = -event.deltaY * 0.5;
    rotateBy(deltaDeg);
  }
}, { passive: false });

let lastTouchPoint = null;

svg.addEventListener('touchstart', (event) => {
  if (event.touches.length === 1) {
    lastTouchPoint = {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
  }
}, { passive: false });

svg.addEventListener('touchmove', (event) => {
  if (event.touches.length === 1 && lastTouchPoint !== null) {
    event.preventDefault();
    const currentPoint = {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
    const center = {
      x: cx,
      y: cy
    };
    const prevAngle = angleFromCenter(lastTouchPoint, center);
    const currentAngle = angleFromCenter(currentPoint, center);
    const deltaRad = normalizeAngleDelta(currentAngle - prevAngle);
    const deltaDeg = (deltaRad * 180) / Math.PI;
    rotateBy(deltaDeg);
    lastTouchPoint = currentPoint;
  }
}, { passive: false });

svg.addEventListener('touchend', (event) => {
  if (event.touches.length === 0) {
    lastTouchPoint = null;
  }
});

</script>

</body>
</html>
