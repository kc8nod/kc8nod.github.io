<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Nested Fraction Donut Chart - SVG</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    background: #f5f5f5;
    font-family: Arial, sans-serif;
  }
  body {
    overflow: hidden;
  }
  .chart-wrap {
    width: 100vw;
    height: 100vh;
    background: white;
  }
  svg {
    display: block;
    width: 100%;
    height: 100%;
    touch-action: none;
  }
  
  .zoom-controls {
    position: fixed;
    top: 10px;
    right: 10px;
    display: flex;
    gap: 8px;
    z-index: 100;
  }
  
  .zoom-btn {
    width: 40px;
    height: 40px;
    background: white;
    border: 1px solid #ccc;
    border-radius: 4px;
    cursor: pointer;
    font-size: 18px;
    font-weight: bold;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .zoom-btn:hover {
    background: #f0f0f0;
  }
  
  .zoom-btn:active {
    background: #e0e0e0;
  }
  
  /* Label styles */
  .fraction-label circle{
    fill: url(#labelGrad);
  }

  .fraction-label text {
    font-size: 0.85em;
    text-anchor: middle;
    dominant-baseline: middle;
    fill: #000;
  }
  
  .decimal-label text {
    font-size: small;
    text-anchor: middle;
    dominant-baseline: middle;
    fill: #000;
  }
  
  .mm-label text {
    font-size: small;
    text-anchor: middle;
    dominant-baseline: middle;
    fill: #000;
  }
</style>
</head>
<body>

<div class="chart-wrap">
  <svg id="chart" width="1024" height="1024" viewBox="0 0 1024 1024">
    <defs>
      <radialGradient id="labelGrad" >
        <stop offset="0%" stop-color="rgba(255,255,255,0.95)" />
        <stop offset="60%" stop-color="rgba(255,255,255,0.60)" />
        <stop offset="100%" stop-color="rgba(255,255,255,0.0)" />
      </radialGradient>
    </defs>
  </svg>
  <div class="zoom-controls">
    <button class="zoom-btn" id="zoomIn" title="Zoom in">+</button>
    <button class="zoom-btn" id="zoomOut" title="Zoom out">−</button>
    <button class="zoom-btn" id="zoomReset" title="Reset zoom">⟲</button>
  </div>
</div>

<script src="https://unpkg.com/svg-pan-zoom@3.6.1/dist/svg-pan-zoom.min.js"></script>
<script>
const svg = document.getElementById("chart");
const width = 1024;
const height = 1024;
const cx = width / 2;
const cy = height / 2;

// Configurable rotation offset for the rings (radians). Change this to rotate the chart.
const startOffset = -Math.PI / 2;

// Rings from 1/2 → 1/32
const fractionRings = [
  2,  // 1/2
  4,  // 1/4
  8,  // 1/8
  16, // 1/16
  32, // 1/32
  64,
  128
];

// SVG parameters
const outermostRadius = width * 0.45;
const holeRadius = width * 0.06;

// GCD function
function gcd(a, b) {
  while (b !== 0) {
    [a, b] = [b, a % b];
  }
  return a;
}

// Generate a color palette for a ring
function getRingColors(slices, ringIndex, hue) {
  const saturation = 70;
  const lightnesses = [40, 55, 70, 85];
  
  const colors = [];
  for (let i = 0; i < slices; i++) {
    const lightness = lightnesses[i % 4];
    colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
  }
  return colors;
}

// Concatenate two arrays with priority
function concatSortedUniquePriority(primary, secondary, tol = 0.002) {
  const uniqPrimary = Array.from(new Set(primary));
  uniqPrimary.sort((a, b) => a - b);
  const result = uniqPrimary.slice();

  for (const s of secondary) {
    let clash = false;
    for (const r of result) {
      if (Math.abs(r - s) < tol) {
        clash = true;
        break;
      }
    }
    if (!clash) result.push(s);
  }

  result.sort((a, b) => a - b);
  return result;
}

// Create SVG arc path
function createArcPath(cx, cy, startAngle, endAngle, innerRadius, outerRadius) {
  const x1 = cx + outerRadius * Math.cos(startAngle);
  const y1 = cy + outerRadius * Math.sin(startAngle);
  const x2 = cx + outerRadius * Math.cos(endAngle);
  const y2 = cy + outerRadius * Math.sin(endAngle);
  
  const x3 = cx + innerRadius * Math.cos(endAngle);
  const y3 = cy + innerRadius * Math.sin(endAngle);
  const x4 = cx + innerRadius * Math.cos(startAngle);
  const y4 = cy + innerRadius * Math.sin(startAngle);
  
  const largeArc1 = endAngle - startAngle > Math.PI ? 1 : 0;
  const largeArc2 = endAngle - startAngle > Math.PI ? 1 : 0;
  
  return [
    `M ${x1} ${y1}`,
    `A ${outerRadius} ${outerRadius} 0 ${largeArc1} 1 ${x2} ${y2}`,
    `L ${x3} ${y3}`,
    `A ${innerRadius} ${innerRadius} 0 ${largeArc2} 0 ${x4} ${y4}`,
    'Z'
  ].join(' ');
}

// Draw slices for a ring
function drawSlices(ringIndex, endAngles, hue) {
  const slices = endAngles.length;
  const innerRadius = ringIndex * ringSpacing + holeRadius;
  const outerRadius = innerRadius + ringSpacing;
  const colors = getRingColors(slices, ringIndex, hue);
  
  const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  group.setAttribute('class', `ring-slices-${ringIndex}`);
  
  for (let i = 1; i <= slices; i++) {
    const startAngle = (i === 1) ? startOffset : endAngles[i - 2];
    const endAngle = endAngles[i - 1];
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    path.setAttribute('d', createArcPath(cx, cy, startAngle, endAngle, innerRadius, outerRadius));
    path.setAttribute('fill', colors[i - 1]);
    path.setAttribute('stroke', 'white');
    path.setAttribute('stroke-width', '1');
    
    group.appendChild(path);
  }
  
  chartGroup.appendChild(group);
}

function createLabel(type, value) {
  const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');

  if (type === 'fraction') {
    const backgroundCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    backgroundCircle.setAttribute('cx', '0');
    backgroundCircle.setAttribute('cy', '0');
    backgroundCircle.setAttribute('r', '1.2em');
    backgroundCircle.setAttribute('fill', 'url(#labelGrad)');
    group.appendChild(backgroundCircle);

    const numText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    numText.setAttribute('dy', '-0.4em');
    numText.textContent = value.numerator;
    group.appendChild(numText);

    const bar = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    bar.textContent = '―';
    group.appendChild(bar);

    const denText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    denText.setAttribute('dy', '0.6em');
    denText.textContent = value.denominator;
    group.appendChild(denText);

    group.classList.add('fraction-label');
  } else if (type === 'decimal') {
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    group.classList.add('decimal-label');
    text.textContent = value.toFixed(3);
    group.appendChild(text);
  } else if (type === 'mm') {
    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
    group.classList.add('mm-label');
    text.textContent = value.toFixed(1) + ' ㎜';
    group.appendChild(text);
  }

  return group;
}

// Draw labels for a ring
function drawLabels(ringIndex, sliceLabels, endAngles, drawLeaders = true, radialAngle = false) {
  const slices = sliceLabels.length;
  const innerRadius = ringIndex * ringSpacing + holeRadius;
  const outerRadius = innerRadius + ringSpacing;
  
  const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  group.setAttribute('class', `ring-labels-${ringIndex}`);
  
  for (let i = 1; i <= slices; i++) {
    const endAngle = endAngles[i - 1];
    const labelText = sliceLabels && sliceLabels[i - 1];
    
    if (labelText) {
      const labelAngle = endAngle;
      const labelRadius = (innerRadius + outerRadius) / 2;
      const labelX = cx + labelRadius * Math.cos(labelAngle);
      const labelY = cy + labelRadius * Math.sin(labelAngle);
      
      // Draw leader line if enabled
      if (drawLeaders) {
        const lineStartRadius = outerRadius - ringSpacing / 5;
        const x1 = cx + lineStartRadius * Math.cos(labelAngle);
        const y1 = cy + lineStartRadius * Math.sin(labelAngle);
        const x2 = cx + lineEndRadius * Math.cos(labelAngle);
        const y2 = cy + lineEndRadius * Math.sin(labelAngle);
        
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', x1);
        line.setAttribute('y1', y1);
        line.setAttribute('x2', x2);
        line.setAttribute('y2', y2);
        line.setAttribute('stroke', 'rgba(0, 0, 0, 0.6)');
        line.setAttribute('stroke-width', '2');
        
        group.appendChild(line);
      }
      
      // Draw label - it's an SVG element
      const clonedLabel = labelText.cloneNode(true);
      clonedLabel.setAttribute('transform', `translate(${labelX}, ${labelY})`);
      
      if (radialAngle) {
        const angle = labelAngle > Math.PI / 2 ? labelAngle + Math.PI : labelAngle;
        const angleDeg = (angle * 180) / Math.PI;
        const existingTransform = clonedLabel.getAttribute('transform');
        clonedLabel.setAttribute('transform', `${existingTransform} rotate(${angleDeg})`);
      }
      
      group.appendChild(clonedLabel);
    }
  }
  
  chartGroup.appendChild(group);
}

// Pre-compute common decimal/mm values
const decimalValues = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
const n = Math.max(...fractionRings);
const decimalFractions = new Array(n).fill(0).map((_, idx) => (idx + 1) / n);
const mmValues = new Array(25).fill(0).map((_, idx) => (idx + 1)).concat([25.4]);
const decimalMillimeters = mmValues.map(val => val / 25.4);

// Build rings array
const rings = [];

// Fraction rings
for (let ringIndex = 0; ringIndex < fractionRings.length; ringIndex++) {
  const slices = fractionRings[ringIndex];
  
  const sliceLabels = new Array(slices).fill(null);
  for (let i = 1; i <= slices; i++) {
    if (gcd(i, slices) === 1) {
      sliceLabels[i - 1] = createLabel('fraction', { numerator: i, denominator: slices });
    }
  }
  
  const sliceAngle = (2 * Math.PI) / slices;
  const endAngles = new Array(slices).fill(0).map((_, idx) => startOffset + (idx + 1) * sliceAngle);
  const labelAngles = endAngles;
  
  rings.push({ ringIndex, endAngles, sliceLabels, labelAngles, drawLeaders: true, radialAngle: false, hue: 120 });
}

// Decimal ring
{
  const slices = 10;
  const sliceAngle = (2 * Math.PI) / slices;
  const endAngles = new Array(slices).fill(0).map((_, idx) => startOffset + (idx + 1) * sliceAngle);
  
  const allDecimals = concatSortedUniquePriority(concatSortedUniquePriority(decimalFractions, decimalMillimeters, 0.002), decimalValues, 0.004);
  const labelAngles = allDecimals.map(val => startOffset + val * 2 * Math.PI);
  const sliceLabels = allDecimals.map(val => createLabel('decimal', val));
  
  rings.push({ ringIndex: fractionRings.length, endAngles, sliceLabels, labelAngles, drawLeaders: false, radialAngle: true, hue: 220 });
}

// MM ring
{
  const sliceAngle = (2 * Math.PI) / mmValues.length;
  const endAngles = mmValues.map(v => startOffset + (v / 25.4) * 2 * Math.PI);
  
  const mmFractions = decimalFractions.map(val => val * 25.4);
  const allMMValues = concatSortedUniquePriority(concatSortedUniquePriority(mmValues, mmFractions, 0.05), decimalValues.map(val => val * 25.4), 0.004 * 25.4);
  const labelAngles = allMMValues.map(val => startOffset + (val / 25.4) * 2 * Math.PI);
  const sliceLabels = allMMValues.map(val => createLabel('mm', val));
  
  rings.push({ ringIndex: fractionRings.length + 1, endAngles, sliceLabels, labelAngles, drawLeaders: false, radialAngle: true, hue: 60 });
}

// Calculate ring spacing
const totalRings = rings.length;
const ringSpacing = (outermostRadius - holeRadius) / totalRings;
const lineEndRadius = outermostRadius - (2 * ringSpacing) + 2;

// Initialize svg-pan-zoom first (it creates its own viewport)
let anchorSvgPoint = { x: cx + outermostRadius, y: cy };
let anchorScreenPoint = null;
let rotationDeg = 0;

const panZoom = svgPanZoom('#chart', {
  zoomEnabled: false,
  panEnabled: false,
  controlIconsEnabled: false,
  fit: false,
  center: false,
  mouseWheelZoomEnabled: false,
  dblClickZoomEnabled: false,
  touchEventsEnabled: false,
  preventMouseEventsDefault: true,
  minZoom: 1.0,
  maxZoom: 20
});

// Now create chartGroup inside svg-pan-zoom's viewport
const viewport = svg.querySelector('.svg-pan-zoom_viewport');
const chartGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
chartGroup.setAttribute('id', 'chartGroup');
viewport.appendChild(chartGroup);

// Draw all rings
rings.forEach(ring => {
  drawSlices(ring.ringIndex, ring.endAngles, ring.hue);
});
rings.forEach(ring => {
  drawLabels(ring.ringIndex, ring.sliceLabels, ring.labelAngles, ring.drawLeaders, ring.radialAngle);
});

// Custom zoom function that respects anchor point
function zoomBy(factor) {
  const currentZoom = panZoom.getZoom();
  const newZoom = Math.max(1.0, Math.min(20, currentZoom * factor));
  
  // Calculate new pan to keep anchor point fixed on screen
  const newPan = {
    x: anchorScreenPoint.x - anchorSvgPoint.x * newZoom,
    y: anchorScreenPoint.y - anchorSvgPoint.y * newZoom
  };
  
  panZoom.zoomBy(factor, false);
  panZoom.pan(newPan);
}

function updateAnchorForRotation() {
  const theta = (rotationDeg * Math.PI) / 180;
  anchorSvgPoint = {
    x: cx + outermostRadius * Math.cos(theta),
    y: cy + outermostRadius * Math.sin(theta)
  };
  const zoom = panZoom.getZoom();
  const pan = panZoom.getPan();
  anchorScreenPoint = {
    x: anchorSvgPoint.x * zoom + pan.x,
    y: anchorSvgPoint.y * zoom + pan.y
  };
}

function resetZoom() {
  panZoom.resetZoom();
  panZoom.fit();
  panZoom.center();
  updateAnchorForRotation();
}

// Fit/center and capture anchor point
panZoom.fit();
panZoom.center();
updateAnchorForRotation();

function rotateBy(deltaDeg) {
  rotationDeg = (rotationDeg + deltaDeg) % 360;
  chartGroup.setAttribute('transform', `rotate(${rotationDeg} ${cx} ${cy})`);
  
  // Don't update anchorScreenPoint - it stays fixed on screen
  // Only update the SVG point that corresponds to that screen position
  const zoom = panZoom.getZoom();
  const pan = panZoom.getPan();
  
  // Calculate which SVG point is currently at the anchor screen position
  anchorSvgPoint = {
    x: (anchorScreenPoint.x - pan.x) / zoom,
    y: (anchorScreenPoint.y - pan.y) / zoom
  };
}

function getCenterScreen() {
  const zoom = panZoom.getZoom();
  const pan = panZoom.getPan();
  return {
    x: cx * zoom + pan.x,
    y: cy * zoom + pan.y
  };
}

function zoomByWheelDelta(deltaY) {
  const factor = Math.exp(-deltaY * 0.01);
  zoomBy(factor);
}

function normalizeAngleDelta(deltaRad) {
  if (deltaRad > Math.PI) return deltaRad - 2 * Math.PI;
  if (deltaRad < -Math.PI) return deltaRad + 2 * Math.PI;
  return deltaRad;
}

function angleFromCenter(point, center) {
  return Math.atan2(point.y - center.y, point.x - center.x);
}

// Attach custom zoom button handlers
document.getElementById('zoomIn').addEventListener('click', () => zoomBy(1.2));
document.getElementById('zoomOut').addEventListener('click', () => zoomBy(1 / 1.2));
document.getElementById('zoomReset').addEventListener('click', resetZoom);

svg.addEventListener('wheel', (event) => {
  event.preventDefault();
  if (event.ctrlKey) {
    zoomByWheelDelta(event.deltaY);
  } else {
    const deltaDeg = -event.deltaY * 0.5;
    rotateBy(deltaDeg);
  }
}, { passive: false });

let lastPinchDistance = null;
let lastTouchPoint = null;

function getTouchDistance(t1, t2) {
  const dx = t1.clientX - t2.clientX;
  const dy = t1.clientY - t2.clientY;
  return Math.sqrt(dx * dx + dy * dy);
}

svg.addEventListener('touchstart', (event) => {
  if (event.touches.length === 2) {
    event.preventDefault();
    lastPinchDistance = getTouchDistance(event.touches[0], event.touches[1]);
    lastTouchPoint = null;
  } else if (event.touches.length === 1) {
    lastTouchPoint = {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
    lastPinchDistance = null;
  }
}, { passive: false });

svg.addEventListener('touchmove', (event) => {
  if (event.touches.length === 2 && lastPinchDistance !== null) {
    event.preventDefault();
    const currentDistance = getTouchDistance(event.touches[0], event.touches[1]);
    const factor = currentDistance / lastPinchDistance;
    if (Math.abs(factor - 1) > 0.01) {
      zoomBy(factor);
      lastPinchDistance = currentDistance;
    }
  } else if (event.touches.length === 1 && lastTouchPoint !== null) {
    event.preventDefault();
    const currentPoint = {
      x: event.touches[0].clientX,
      y: event.touches[0].clientY
    };
    const center = getCenterScreen();
    const prevAngle = angleFromCenter(lastTouchPoint, center);
    const currentAngle = angleFromCenter(currentPoint, center);
    const deltaRad = normalizeAngleDelta(currentAngle - prevAngle);
    const deltaDeg = (deltaRad * 180) / Math.PI;
    rotateBy(deltaDeg);
    lastTouchPoint = currentPoint;
  }
}, { passive: false });

svg.addEventListener('touchend', (event) => {
  if (event.touches.length < 2) {
    lastPinchDistance = null;
  }
  if (event.touches.length === 0) {
    lastTouchPoint = null;
  }
});

</script>

</body>
</html>
