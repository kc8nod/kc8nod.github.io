<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Nested Fraction Donut Chart</title>
<style>
  body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background: #f5f5f5;
  }
  .chart-wrap {
    position: relative;
    width: 800px;
    height: 800px;
  }
  canvas {
    position: absolute;
    top: 0;
    left: 0;
    border-radius: 8px;
    width: 800px;
    height: 800px;
    background: transparent;
  }
  #slices {
    background: white;
    z-index: 0;
  }
  #labels {
    z-index: 1;
    pointer-events: none;
  }
</style>
</head>
<body>

<div class="chart-wrap">
  <canvas id="slices" width="1024" height="1024"></canvas>
  <canvas id="labels" width="1024" height="1024"></canvas>
</div>

<script>
const slicesCanvas = document.getElementById("slices");
const labelsCanvas = document.getElementById("labels");
const slicesCtx = slicesCanvas.getContext("2d");
const labelCtx = labelsCanvas.getContext("2d");

// Match centers to canvas dimensions
const cx = slicesCanvas.width / 2;
const cy = slicesCanvas.height / 2;
// Configurable rotation offset for the rings (radians). Change this to rotate the chart.
const startOffset = -Math.PI / 2;

// Rings from 1/2 â†’ 1/32
const fractionRings = [
  2,  // 1/2
  4,  // 1/4
  8,  // 1/8
  16, // 1/16
  32,  // 1/32
  64
];

// Canvas parameters
const outermostRadius = slicesCanvas.width * 0.45; // leave some margin around the edges
const holeRadius = slicesCanvas.width * .08;
// totalRings and ringSpacing will be calculated after the rings array is built


// GCD function
function gcd(a, b) {
  while (b !== 0) {
    [a, b] = [b, a % b];
  }
  return a;
}


// Generate a color palette for a ring using 4 color variations repeated in a pattern.
// All slices share the same hue based on ringIndex, and saturation is consistent.
// 4 lightness levels cycle through the slices.
function getRingColors(slices, ringIndex) {
  const hue = (ringIndex * 60) % 360; // hue based on ring index
  const saturation = 70; // consistent saturation across rings
  const lightnesses = [40, 55, 70, 85]; // 4 lightness variations
  
  const colors = [];
  for (let i = 0; i < slices; i++) {
    const lightness = lightnesses[i % 4]; // cycle through 4 lightness levels
    colors.push(`hsl(${hue}, ${saturation}%, ${lightness}%)`);
  }
  return colors;
}

// Concatenate two arrays of numbers: primary has priority. For each value in
// `secondary`, it is only added if there is no existing value in the result
// within `tol`. Returned array is sorted ascending and deduplicated.
function concatSortedUniquePriority(primary, secondary, tol = 0.002) {
  const uniqPrimary = Array.from(new Set(primary));
  uniqPrimary.sort((a, b) => a - b);
  const result = uniqPrimary.slice();

  for (const s of secondary) {
    let clash = false;
    for (const r of result) {
      if (Math.abs(r - s) < tol) {
        clash = true;
        break;
      }
    }
    if (!clash) result.push(s);
  }

  result.sort((a, b) => a - b);
  return result;
}

// Draw slices for a single ring.
// The start angle for slice i is the end angle of slice i-1, or startOffset for the first slice.
function drawSlices(ringIndex, endAngles) {
  const slices = endAngles.length;
  const innerRadius = ringIndex * ringSpacing + holeRadius;
  const outerRadius = innerRadius + ringSpacing;

  // `endAngles` must be provided and have one end angle per slice.
  if (!Array.isArray(endAngles) || endAngles.length !== slices) {
    throw new Error(`drawSlices: endAngles must be an array of length ${slices}`);
  }
  const ends = endAngles;

  const colors = getRingColors(slices, ringIndex); // colors with hue based on ring

  for (let i = 1; i <= slices; i++) {
    const startAngle = (i === 1) ? startOffset : ends[i - 2];
    const endAngle = ends[i - 1];

    // Draw slice
    slicesCtx.beginPath();
    slicesCtx.moveTo(cx, cy);
    slicesCtx.arc(cx, cy, outerRadius, startAngle, endAngle);
    slicesCtx.arc(cx, cy, innerRadius, endAngle, startAngle, true);
    slicesCtx.closePath();
    slicesCtx.fillStyle = colors[i - 1];
    slicesCtx.fill();
  }
}

// Draw labels and leaders for a single ring.
// If radialAngle is true, labels are rotated to match the angle from the center.
function drawLabels(ringIndex, sliceLabels, endAngles, drawLeaders = true, radialAngle = false) {
  const slices = sliceLabels.length;
  const innerRadius = ringIndex * ringSpacing + holeRadius;
  const outerRadius = innerRadius + ringSpacing;

  // `endAngles` must be provided and have one end angle per slice.
  if (!Array.isArray(endAngles) || endAngles.length !== slices) {
    throw new Error(`drawLabels: endAngles must be an array of length ${slices}`);
  }
  const ends = endAngles;

  for (let i = 1; i <= slices; i++) {
    const endAngle = ends[i - 1];

    // If a label was provided for this slice, draw its leader and label now
    const labelText = sliceLabels && sliceLabels[i - 1];
    if (labelText) {
      const labelAngle = endAngle; // place label slightly clockwise of center
      const labelRadius = (innerRadius + outerRadius) / 2;
      const labelX = cx + labelRadius * Math.cos(labelAngle);
      const labelY = cy + labelRadius * Math.sin(labelAngle);

      // Draw leader line if enabled
      if (drawLeaders) {
        const lineStartRadius = (outerRadius - ringSpacing / 5);
        const x1 = cx + lineStartRadius * Math.cos(labelAngle);
        const y1 = cy + lineStartRadius * Math.sin(labelAngle);
        const x2 = cx + lineEndRadius * Math.cos(labelAngle);
        const y2 = cy + lineEndRadius * Math.sin(labelAngle);

        labelCtx.strokeStyle = "rgba(0,0,0,0.6)";
        labelCtx.lineWidth = 1;
        labelCtx.beginPath();
        labelCtx.moveTo(x1, y1);
        labelCtx.lineTo(x2, y2);
        labelCtx.stroke();
      }

      // Draw label text on top
      labelCtx.fillStyle = "#000";
      labelCtx.font = ringIndex < 2 ? "16px Arial" : "12px Arial";
      labelCtx.textAlign = "center";
      labelCtx.textBaseline = "middle";
      
      if (radialAngle) {
        // Rotate text to match the radial angle
        labelCtx.save();
        labelCtx.translate(labelX, labelY);
        labelCtx.rotate(labelAngle > Math.PI / 2 ? labelAngle + Math.PI : labelAngle); 
        labelCtx.fillText(labelText, 0, 0);
        labelCtx.restore();
      } else {
        labelCtx.fillText(labelText, labelX, labelY);
      }
    }
  }
}

// Note: slices and labels are drawn separately by drawSlices() and drawLabels()

// Pre-compute common decimal/mm values used by multiple rings
const decimalValues = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
const n = Math.max(...fractionRings);
const decimalFractions = new Array(n).fill(0).map((_, idx) => (idx + 1) / n);
const mmValues = new Array(25).fill(0).map((_, idx) => (idx + 1)).concat([25.4]);
const decimalMillimeters = mmValues.map(val => val / 25.4);

// Build a table of ring data: endAngles, sliceLabels, and labelAngles for each ring
const rings = [];

// Fraction rings (1/2, 1/4, 1/8, etc.)
for (let ringIndex = 0; ringIndex < fractionRings.length; ringIndex++) {
  const slices = fractionRings[ringIndex];
  
  // Build label array for this ring
  const sliceLabels = new Array(slices).fill(null);
  for (let i = 1; i <= slices; i++) {
    if (gcd(i, slices) === 1) sliceLabels[i - 1] = `${i}/${slices}`;
  }
  
  // Build end angles
  const sliceAngle = (2 * Math.PI) / slices;
  const endAngles = new Array(slices).fill(0).map((_, idx) => startOffset + (idx + 1) * sliceAngle);
  
  // Label angles match end angles for fractions
  const labelAngles = endAngles;
  
  rings.push({ ringIndex, endAngles, sliceLabels, labelAngles, drawLeaders: false, radialAngle: false });
}

// Decimal ring (10 slices)
{
  const slices = 10;
  const sliceAngle = (2 * Math.PI) / slices;
  const endAngles = new Array(slices).fill(0).map((_, idx) => startOffset + (idx + 1) * sliceAngle);
  
  // Build decimal labels and angles using pre-computed values
  const allDecimals = concatSortedUniquePriority(concatSortedUniquePriority(decimalFractions, decimalMillimeters, 0.002), decimalValues, 0.004);
  const labelAngles = allDecimals.map(val => startOffset + val * 2 * Math.PI);
  const sliceLabels = allDecimals.map(val => val.toFixed(3));
  
  rings.push({ ringIndex: fractionRings.length, endAngles, sliceLabels, labelAngles, drawLeaders: false, radialAngle: true });
}

// MM ring
{
  const sliceAngle = (2 * Math.PI) / mmValues.length;
  const endAngles = new Array(mmValues.length).fill(0).map((_, idx) => startOffset + (idx + 1) * sliceAngle);
  
  // Build mm labels and angles using pre-computed values
  const mmFractions = decimalFractions.map(val => val * 25.4);
  const allMMValues = concatSortedUniquePriority(concatSortedUniquePriority(mmValues, mmFractions, 0.05), decimalValues.map(val => val * 25.4), 0.004 * 25.4);
  const labelAngles = allMMValues.map(val => startOffset + (val / 25.4) * 2 * Math.PI);
  const sliceLabels = allMMValues.map(val => val.toFixed(1) + " mm");
  
  rings.push({ ringIndex: fractionRings.length + 1, endAngles, sliceLabels, labelAngles, drawLeaders: false, radialAngle: true });
}

// Calculate totalRings and ringSpacing based on the rings array
const totalRings = rings.length;
const ringSpacing = (outermostRadius - holeRadius) / totalRings;
const lineEndRadius = outermostRadius - (2 * ringSpacing) + 2;

// Draw all rings and labels
rings.forEach(ring => {
  drawSlices(ring.ringIndex, ring.endAngles);
  drawLabels(ring.ringIndex, ring.sliceLabels, ring.labelAngles, ring.drawLeaders, ring.radialAngle);
});

</script>

</body>
</html>
